<!DOCTYPE html>
<html lang="en">
<head>
	<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>

	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<title>Git常用命令的学习与理解 | Jeff&#39;s Blog</title>

	<link rel="stylesheet" href="/css/style.css" type="text/css" media="all" />

	<style>
         
		header {
            position: fixed;
            top: 0;
            width: 100%;  
            background-color: #fff;  
             
        }
    </style>
	
	<script>
		
		$(document).ready(function () {
			
			var header = $('header');
			
			
			var lastScrollTop = 0;
	
			
			$(window).scroll(function () {
				
				var st = $(this).scrollTop();
				
				
				if (st > lastScrollTop) {
					
					header.addClass('hidden');
				} else {
					
					header.removeClass('hidden');
				}
	
				
				lastScrollTop = st;
			});
		});
	</script>
	


</head>

<body>

<header class="site-header">
  <nav class="site-nav">
    <a class="logo" href="https://goxpp.github.io">
      Jeff&#39;s Blog
    </a>
    <ul class="main-menu">
      
      <li>
        <a href="/posts">Posts</a>
      </li>
      
      <li>
        <a href="/about">About</a>
      </li>
      
    </ul>
  </nav>
</header>


<main class="content">

<link rel="stylesheet" href="/css/md.css" type="text/css" media="all" />


<h1>Git常用命令的学习与理解</h1>


<h2 id="初始化">初始化</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone &lt;repository name&gt; <span style="color:#75715e">#repository name为远端仓库，该操作会把远端仓库克隆到本地，并把执行该克隆命令的文件夹做为git 本地仓库。</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git init <span style="color:#75715e">#指定某个仓库做为git本地仓库，为初始化操作</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> git pull &lt;repository name&gt; <span style="color:#75715e">#repository name为远端仓库 </span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git pull &lt;repository name&gt; &lt;branch name&gt;#指定拉取该仓库某个分支的代码到本地
</span></span></code></pre></div><blockquote>
<p><code>git init</code> + <code>git pull -b &lt;branch name&gt;&lt;repository name&gt;</code> 在效果上等同于 <code>git clone &lt;repository name&gt;</code>。 但是在初始化的时候更推荐后者。因为后者可以默认与该仓库下所有分支都建立联系。前者只与<code>git pull -b &lt;branch name&gt; &lt; repository name&gt;</code>时 的branch name 建立联系。</p>
</blockquote>
<h2 id="分支-">分支 🔀</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git branch uat <span style="color:#75715e">#新建一个uat分支，但是还在当前分支上，不会切换到uat分支</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git branch -d &lt;branch name&gt;#删除本地分支
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push &lt;remote_name&gt; --delete &lt;branch_name&gt; <span style="color:#75715e">#删除远端分支&lt;remote_name&gt;为远端仓库一般是origin &lt;remote_name&gt;为分支名字</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git checkout uat <span style="color:#75715e">#从当前分支将分支切换到uat分支</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git checkout -b uat#新建一个uat分支，并切换到uat分支
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git checkout &lt;commit-id&gt;#命令切换到某个特定的提交，这相当于创建一个临时分支。
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git branch -u &lt;remote-name&gt;/&lt;remote-branch&gt; <span style="color:#75715e">#sa本地分支与远程分支进行关联</span>
</span></span></code></pre></div><blockquote>
<p>如果在dev分支进行操作时，uat有bug需要checkout到uat，但是不想对dev的修改进行commit，可以用<code>git stash</code> 将修改放到git的隐藏栈中，Git 会创建一个临时的提交对象来保存这些更改，同时清空工作目录和暂存区，以便你可以在干净的状态下进行其他操作。</p>
<p><code>git stash save</code>会将未提交的更改保存为一个临时的提交对象，并将 HEAD 指针移动到最新的提交。这个临时提交对象包含了你的工作目录和暂存区的更改。<strong>这个临时提交不属于任何分支，而是作为一个独立的提交存在</strong>。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git stash save &lt;message&gt; <span style="color:#75715e">#message为对此次暂存进行描述。过期</span>
</span></span><span style="display:flex;"><span>git stash push -m <span style="color:#e6db74">&#34;message&#34;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git stash list <span style="color:#75715e">#查看所有暂存</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git stash apply stash@<span style="color:#f92672">{</span>n<span style="color:#f92672">}</span>  与⬆️搭配使用，将该分支代码恢复到某个暂存索引。
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git stash apply <span style="color:#75715e">#进行将刚刚的暂存应用到当前分支。</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git stash pop <span style="color:#75715e">#应用后将此次暂存删除</span>
</span></span></code></pre></div><blockquote>
<p>该应用为应用到本地的分支上</p>
</blockquote>
<h2 id="好用的标签-">好用的标签 🏷️</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git tag &lt;tag name&gt; <span style="color:#75715e">#给当前的版本改动打一个标签</span>
</span></span></code></pre></div><blockquote>
<p>该标签对所有分支有效，是对该分支<strong>已经commit</strong>的代码打tag</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git tag <span style="color:#75715e">#查看本地的标签</span>
</span></span></code></pre></div><blockquote>
<p>标签需要被打标签者push后，协作者👨🏻‍💻拉取该标签后才可以用此命令看到</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git tag -d &lt;tag name&gt;# 删除本地标签，&lt;tag name&gt;为标签名
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push &lt;repository name&gt; --tags <span style="color:#75715e"># 将本地所有标签推送到远端</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push &lt;repository name&gt; &lt;tag name&gt;#将本地指定标签上传到远端
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push origin --delete &lt;tag_name&gt; <span style="color:#75715e">#删除远端某一标签</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git fetch -- tags#拉取所有远端tag
</span></span></code></pre></div><p><!-- raw HTML omitted --><em>我上传了一个tag A，同事也将此tag pull到本地，然后我将该tag进行本地与远端均删除。 重新上传一个新的同样名字的tag A，这时，同事没有pull代码，就用tag 新建了一个分支，这时他用的是之前的tag。</em><!-- raw HTML omitted --></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git branch &lt;branch name&gt; &lt;tag nmae&gt; <span style="color:#75715e">#将tag内容新建一个分支</span>
</span></span></code></pre></div><h2 id="合并">合并🈴️</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git merge &lt;branch name&gt; <span style="color:#75715e">#将引用里的分支名合并到当前分支</span>
</span></span></code></pre></div><blockquote>
<p>相对本地操作</p>
</blockquote>
<blockquote>
<ol>
<li>
<p>普通合并（recursive）： 这是 Git <strong>默认</strong>的合并策略，也是最常用的策略。它会尝试进行三路合并，自动合并非冲突的修改，并在有冲突的地方产生冲突标记，需要手动解决。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git merge --strategy<span style="color:#f92672">=</span>recursive feature-branch
</span></span></code></pre></div></li>
<li>
<p>快进合并（fast-forward）： 当合并的两个分支形成线性关系时，且目标分支没有新的提交，可以使用快进合并。快进合并会将目标分支指针直接移动到要合并的分支的最新提交，相当于没有产生新的合并提交。例如：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git merge --strategy<span style="color:#f92672">=</span>fast-forward feature-branch
</span></span></code></pre></div><ol start="3">
<li>
<p>递归合并（octopus）： 递归合并策略用于同时合并多个分支。它可以一次性将多个分支的修改合并到当前分支，并生成一个新的合并提交。递归合并常用于同时合并多个特性分支或多个远程分支。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span> git merge --strategy<span style="color:#f92672">=</span>octopus feature-branch1 feature-branch2
</span></span></code></pre></div></li>
<li>
<p>简单合并（resolve）： 简单合并策略是一种比较保守的策略，它会直接将两个分支的修改进行比较，并尝试自动合并。如果有冲突，它会停止合并并提示冲突，需要手动解决。简单合并适用于简单的合并场景。例如：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git merge --strategy<span style="color:#f92672">=</span>resolve feature-branch
</span></span></code></pre></div></blockquote>
<h2 id="撤回">撤回⏪</h2>
<h3 id="add后">add后</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git reset HEAD &lt;file&gt; <span style="color:#75715e">#撤销对某一文件的add</span>
</span></span></code></pre></div><h3 id="commit后">commit后</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git log <span style="color:#75715e">#查看记录，会显示唯一确定一次commit的标识码</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git revert &lt;commit num&gt; <span style="color:#75715e">#创建一个新的提交，用于撤销指定的commit; 还可以用于push后的撤回</span>
</span></span></code></pre></div><h4 id="git-reset-的三种模式与区别">git reset 的三种模式与区别</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git reset —soft &lt;commit num&gt; 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#会将 HEAD 指针和分支引用移动到目标提交，但不会更改工作目录和暂存区的内容。这意味着之后可以重新提交或修改之前的提交。理解为温柔的回退,执行该操作后，commit前修改的记录还在暂存区，不需要重新add。</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git reset —mixed commitnum
</span></span><span style="display:flex;"><span><span style="color:#75715e">#默认方式，这种模式下，会将 HEAD 指针和分支引用移动到目标提交，并重置暂存区的内容，但不会更改工作目录的内容。这意味着之后需要重新添加和提交更改。执行该操作后，重置暂存区内容，也就是此次变更需要重新add到暂存区。</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git reset —hard commitnum
</span></span><span style="display:flex;"><span><span style="color:#75715e">#这种模式下，会将 HEAD 指针和分支引用移动到目标提交，并且完全重置工作目录、暂存区和之后的更改。这意味着之后的更改将被丢弃，请确保在执行此操作之前保存好重要的更改。</span>
</span></span></code></pre></div><blockquote>
<p>Ex:</p>
<p>新建A.txt，add后commit -m &ldquo;generate A.txt&rdquo;（commit号为 aa1）</p>
<p>此时，A.txt 文件中有两条记录 ：Test1 Test2</p>
<p>变更A.txt ，删除字段Test2，add后commit -m &ldquo;delete Test2&rdquo; (commit号为bb2)</p>
<p>执行git reset 到 aa1</p>
<p><code>git reset --&lt;model&gt; aa1</code></p>
<ul>
<li>
<p>soft模式下，add暂存区有Test2的删除记录，工作区A.txt 为Test1</p>
</li>
<li>
<p>mixed模式下，add暂存区无Test2的删除记录，工作区A.txt为Test1，需要重新将删除 Test2的操作add到暂存区。</p>
</li>
<li>
<p>hard模式下，add暂存区无Test2的删除记录，工作区为Test1 Test2，相当于上一次commit &ldquo;generate A.txt&quot;后，什么也没有发生。</p>
</li>
</ul>
</blockquote>
<h3 id="push后">push后</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git revert &lt;commit num&gt; <span style="color:#75715e">#创建一个新的提交，用于撤销指定的commit; 还可以用于push后的撤回</span>
</span></span></code></pre></div><blockquote>
<p>执行此指令后，Git 会自动打开一个编辑器，需要编写撤销提交的相关信息。可以修改信息后保存并关闭编辑器。</p>
</blockquote>
<h2 id="远程仓库操作相关">远程仓库操作相关</h2>
<h3 id="查看与删除">查看与删除</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git remote <span style="color:#75715e"># 查看与本地仓库关联的远程仓库信息，如远程仓库的名称;</span>
</span></span><span style="display:flex;"><span>git remote -v <span style="color:#75715e">#查看远端仓库的详细URL等</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git remote add &lt;repository name&gt; &lt;url&gt;#将一个新的远程仓库添加到本地仓库的远程仓库列表中
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git remote remove &lt;repository name&gt;#从本地仓库的远程仓库列表中移除指定的远程仓库。
</span></span></code></pre></div><h3 id="拉取">拉取</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git pull <span style="color:#75715e">#从远程仓库获取最新的代码更新，并将其合并到当前分支</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git fetch <span style="color:#75715e">#从远程仓库获取最新的分支信息，但不会自动合并到本地分支。需要通过切换到远程分支或进行合并操作来更新本地分支。</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push --force <span style="color:#75715e">#即使它会覆盖远程仓库中的提交。请谨慎使用此选项，因为它可能会导致数据丢失或不一致</span>
</span></span></code></pre></div><h3 id="推送">推送</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push &lt;repository name&gt; &lt;branch&gt; <span style="color:#75715e">#将指定的本地分支推送到远程仓库。&lt;remote&gt; 是远程仓库的名称，&lt;branch&gt; 是本地分支的名称。如果已经与远端仓库关联，可直接使用 `git push`</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git push -u &lt;repository name&gt; &lt;branch&gt; <span style="color:#75715e">#将本地分支推送到远程仓库，并将远程分支设置为该本地分支的上游分支。这样可以建立本地分支与远程分支之间的跟踪关系，以后可以使用 git pull 或 git push 简化命令。</span>
</span></span></code></pre></div><h2 id="高级重写操作">高级重写操作</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git commit --amend <span style="color:#75715e">#修改提交消息</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git rebase -i <span style="color:#75715e">#修改提交消息、合并提交、删除提交等</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git rebase -i HEAD~3 <span style="color:#75715e">#修改最近的三次commit 会打开一个编辑器，可更改文件内容，将文件前的操作命令进行修改，以达到修改commit的目的</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#drop：删除提交，类似于 d。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#edit：编辑提交，允许你在重新应用提交之前对提交进行修改。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#reword：修改提交信息，类似于 r。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#fixup：合并提交，但不保留提交信息，类似于 f。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#squash：合并提交，保留提交信息，类似于 s。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#exec：执行指定的 shell 命令。</span>
</span></span></code></pre></div><blockquote>
<p>删除某个提交后，工作区和暂存区完全回退</p>
<p>与<code>git reset --hard</code>不同的是，前者重写后的提交历史将被修改，原始提交将被移除。后者只能回退到某一特定提交，这一特定提交之前的提交也会被删除。</p>
<p><code>git rebase -i</code> 更适合对提交历史进行高级编辑，而 <code>git reset --hard</code> 更适合重置当前分支的状态到某个特定的提交。</p>
</blockquote>
<h2 id="一些缩写以及含义">一些缩写以及含义</h2>
<ul>
<li><code>-u</code> 或 <code>--set-upstream</code>: 将本地分支与远程分支建立关联关系。</li>
<li><code>-v</code> 或 <code>--verbose</code>: 显示详细的输出信息，更多地展示命令执行过程。</li>
<li><code>-a</code> 或 <code>--all</code>: 显示所有分支（包括远程分支和本地分支）。</li>
<li><code>-f</code> 或 <code>--force</code>: 强制执行操作，覆盖现有的对象或分支。</li>
<li><code>-m</code> 或 <code>--merge</code>: 执行合并操作。</li>
<li><code>-r</code> 或 <code>--remote</code>: 显示远程仓库的相关信息。</li>
<li><code>-p</code> 或 <code>--patch</code>: 以交互式方式显示并选择要提交的文件的补丁。</li>
<li><code>-s</code> 或 <code>--short</code>: 显示简短的输出信息，只展示关键信息。</li>
</ul>
<h2 id="理解git的原理">理解Git的原理</h2>
<p>Git 使用一种称为对象存储（Object Store）的机制来管理文件的内容和历史记录。对象存储是 Git 的核心组成部分，它负责存储所有文件的内容和元数据，并以唯一的哈希值来标识每个对象</p>
<ol>
<li>Blob（文件对象）：Blob 对象代表着 Git 仓库中的文件内容。它保存着文件的数据，并且通过 SHA-1 哈希值来标识。每次你对文件进行修改并提交时，Git 会为该文件创建一个新的 Blob 对象来保存修改后的内容。</li>
<li>Tree（目录对象）：Tree 对象代表着 Git 仓库中的目录结构。它保存着目录的信息，包括文件名、文件类型和对应的 Blob 或 Tree 对象的哈希值。通过递归地组合 Tree 对象，Git 可以构建出完整的目录结构。</li>
<li>Commit（提交对象）：Commit 对象代表着 Git 仓库中的一个代码提交。它包含了作者、提交时间、提交信息以及指向当前提交所对应的树对象的指针。每次你执行 <code>git commit</code> 命令时，Git 会创建一个新的 Commit 对象，并将当前的工作目录状态转化为一个树对象。</li>
</ol>
<p><em>举个例子，假设你的 Git 仓库中有一个名为 <code>src</code> 的目录，其中包含了 <code>main.c</code> 和 <code>util.h</code> 两个文件。在提交代码时，Git 会将 <code>src</code> 目录转化为一个 Tree 对象，其中包含了对应的 Blob 对象（文件对象）。当你修改了 <code>main.c</code> 文件后，Git 会创建一个新的 Blob 对象来保存修改后的内容，并更新 Tree 对象中对应的文件哈希值。然后，Git 会创建一个新的 Commit 对象，其中包含了指向最新的树对象的指针。这样，你就可以通过 Commit 对象来访问到该次提交所对应的文件对象。</em></p>
<h3 id="引用">引用</h3>
<p>分支引用、标签引用、远程引用 三种不说明</p>
<h4 id="一种特殊引用head">一种特殊引用HEAD</h4>
<p>当 <code>HEAD</code> 指向分支时，它指向该分支的最新提交；当 <code>HEAD</code> 指向具体的提交时，它直接指向该提交。</p>
<p>如当前在main分支，head指向为main分支的最新的一次提交，checkout branch dev时，head指向dev分支的最新的一次提交。</p>
<p>在reset 到某个commit num时，head指向该提交。</p>
<p>thanks</p>


</main>
	
<footer>
	<p>&copy;2024 Jeff&#39;s Blog</p>
</footer>

</body>
</html>

